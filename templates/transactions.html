<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bank Statement</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        select, input[type="date"] { margin-right: 10px; }
        button { margin-top: 10px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
</head>
<body>
    <h2>Bank Statement</h2>
    <a href="/merchants">View Merchants</a>

    <!-- Date Range Picker Controls -->
    <div>
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate">
        
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate">
        
        <button onclick="applyFilter()">Apply Filter</button>
    </div>

    <!-- Category Filter -->
    <label for="categoryFilter">Filter by Category:</label>
    <select id="categoryFilter" multiple>
        {% for category in categories %}
        <option value="{{ category[0] }}" {% if category[0] in selected_categories %}selected{% endif %}>{{ category[0] }}</option>
        {% endfor %}
    </select>
    <label for="stackToggle">Stacked Bar Chart</label>
    <input type="checkbox" id="stackToggle" onchange="toggleStackedMode()" />

    <!-- Bucket Size Selection -->
    <div>
        <label>Bucket Size:</label>
        <input type="radio" id="bucketDay" name="bucketSize" value="day" onchange="updateBucketSize('day')"> 
        <label for="bucketDay">Day</label>
        <input type="radio" id="bucketWeek" name="bucketSize" value="week" onchange="updateBucketSize('week')"> 
        <label for="bucketWeek">Week</label>
        <input type="radio" id="bucketMonth" name="bucketSize" value="month" onchange="updateBucketSize('month')"> 
        <label for="bucketMonth">Month</label>
    </div>

    <div>Total Amount: $<span id="totalAmount">{{ "%.2f"|format(total_amount or 0) }}</span></div>
    
    <div>
        <canvas id="amountChart" style="width: 100%; height: 150px;"></canvas>
    </div>

    <table>
        <thead>
            <tr>
                <th>Hash</th>
                <th>Account</th>
                <th>Date</th>
                <th>Merchant</th>
                <th>Amount</th>
                <th>Category</th>
                <th>Note</th>
            </tr>
        </thead>
        <tbody id="transaction-body">
            {% for tx in transactions %}
            <tr>
                <td>{{ tx[0] if tx[0] is not none else '' }}</td>
                <td>{{ tx[1] if tx[1] is not none else '' }}</td>
                <td>{{ tx[2] if tx[2] is not none else '' }}</td>
                <td>{{ tx[3] if tx[3] is not none else '' }}</td>
                <td>{{ tx[4] if tx[4] is not none else '' }}</td>
                <td>{{ tx[5] if tx[5] is not none else '' }}</td>
                <td>{{ tx[6] if tx[6] is not none else '' }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    <script>
        let chart;

        document.addEventListener("DOMContentLoaded", function() {
            const today = new Date().toISOString().split('T')[0];
            const startOfYear = new Date(new Date().getFullYear(), 0, 1).toISOString().split('T')[0];
            const urlParams = new URLSearchParams(window.location.search);

            // Set date range based on URL params or default to the current year
            document.getElementById('startDate').value = urlParams.get('startDate') || startOfYear;
            document.getElementById('endDate').value = urlParams.get('endDate') || today;

            // Initialize the bucket size from URL params
            const bucketSize = urlParams.get('bucketSize') || 'day';
            document.querySelector(`input[name="bucketSize"][value="${bucketSize}"]`).checked = true;

            fetchAndRenderChartData();
        });

        function toggleStackedMode() {
            fetchAndRenderChartData(); // Reload the chart with the new stacking mode
        }

        function fetchAndRenderChartData() {
            const ctx = document.getElementById('amountChart').getContext('2d');
            const params = new URLSearchParams(window.location.search);
            const isStacked = document.getElementById('stackToggle').checked; // Check if stacked mode is enabled

            fetch('/data?' + params.toString())
                .then(response => response.json())
                .then(data => {
                    // Check if data is empty
                    if (!data || Object.keys(data).length === 0) {
                        console.warn("No data available for the selected criteria.");
                        if (chart) chart.destroy(); // Clear chart if no data
                        return;
                    }

                    const dates = Object.values(data)[0].map(entry => entry.date); // Use dates from the first category

                    let datasets;
                    if (isStacked && Object.keys(data).length > 1) {
                        // Separate datasets for each category when stacked mode is enabled
                        datasets = Object.keys(data).map((category, index) => ({
                            label: category,
                            data: data[category].map(entry => -entry.amount), // Invert amounts
                            backgroundColor: `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.5)`,
                            borderColor: `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 1)`,
                            borderWidth: 1
                        }));
                    } else {
                        // Single combined dataset
                        const combinedData = dates.map((date, i) => 
                            Object.keys(data).reduce((sum, category) => sum + data[category][i].amount, 0)
                        );
                        datasets = [{
                            label: 'Combined Amount',
                            data: combinedData.map(value => -value), // Invert amounts
                            backgroundColor: 'rgba(75, 192, 192, 0.5)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        }];
                    }

                    if (chart) chart.destroy();

                    chart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: dates,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    stacked: isStacked, // Stack x-axis when in stacked mode
                                    time: {
                                        unit: params.get('bucketSize') || 'day',
                                        displayFormats: {
                                            day: 'MMM d',
                                            week: 'MMM d',
                                            month: 'MMM yyyy'
                                        }
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    stacked: isStacked, // Stack y-axis when in stacked mode
                                    ticks: {
                                        callback: function(value) {
                                            return Math.abs(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                })
                .catch(error => console.error('Error loading the data:', error));
        }

        function applyFilter() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            const selectedCategories = Array.from(document.getElementById('categoryFilter').selectedOptions).map(option => option.value);
            const bucketSize = document.querySelector('input[name="bucketSize"]:checked').value;

            const queryParams = new URLSearchParams();

            if (startDate) queryParams.set('startDate', startDate);
            if (endDate) queryParams.set('endDate', endDate);
            queryParams.set('bucketSize', bucketSize);
            selectedCategories.forEach(cat => queryParams.append('tx_category', cat));

            window.location.search = queryParams.toString();
        }

        function updateBucketSize(size) {
            // Update bucket size in URL and refresh data with new setting
            const params = new URLSearchParams(window.location.search);
            params.set('bucketSize', size);
            window.location.search = params.toString();
        }
    </script>
</body>
</html>
